
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>pyCICY.pyCICY &#8212; pyCICY 0.01 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyCICY.pyCICY</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Fri Jun 08 16:45:23 2018</span>

<span class="sd">pyCICY - A python CICY toolkit. It allows for computation of </span>
<span class="sd">line bundle cohomologies over Complete Intersection</span>
<span class="sd">Calabi Yau manifolds.</span>

<span class="sd">Further, it includes functions to determine various </span>
<span class="sd">topological quantities, such as Chern classes, hodge numbers</span>
<span class="sd">and triple intersection numbers.</span>

<span class="sd">Authors</span>
<span class="sd">-------</span>
<span class="sd">Magdalena Larfors (magdalena.larfors@physics.uu.se)</span>
<span class="sd">Robin Schneider (robin.schneider@physics.uu.se)</span>

<span class="sd">Version</span>
<span class="sd">-------</span>
<span class="sd">0.01 - pyCICY toolkit made available - 29.5.2019.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># libraries</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="k">import</span> <span class="n">randint</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">import</span> <span class="nn">scipy.special</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">texttable</span> <span class="k">import</span> <span class="n">Texttable</span>
<span class="kn">import</span> <span class="nn">os</span>


<div class="viewcode-block" id="CICY"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY">[docs]</a><span class="k">class</span> <span class="nc">CICY</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;~/Documents/data/CICY/&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The CICY class. Allows for computation of various topological quantities.</span>
<span class="sd">        Main function is the computation of line bundle cohomologies.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Internal name of the CICY object; only used for debugging.</span>
<span class="sd">        conf : array[nProj, K+1]</span>
<span class="sd">            The CICY configuration matrix, including the first col for the</span>
<span class="sd">            projective spaces.</span>
<span class="sd">        doc : bool, optional</span>
<span class="sd">            Turns the documentation on, which prints calculation into the console</span>
<span class="sd">            , by default False.</span>
<span class="sd">        dir : str, optional</span>
<span class="sd">            path name for file save during debugging, by default &#39;~/Documents/data/CICY/&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Exception</span>
<span class="sd">            If the configuration matrix is not Calabai Yau.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The famous quintic:</span>

<span class="sd">        &gt;&gt;&gt; Q = CICY(&#39;quintic&#39;, [[4,5]])</span>

<span class="sd">        or the tetra quadric:</span>

<span class="sd">        &gt;&gt;&gt; T = CICY(&#39;tetra&#39;, [[1,2],[1,2],[1,2],[1,2]])</span>

<span class="sd">        or the manifold #7833 of the CICYlist:</span>

<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># define some variables which will make our life easier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">conf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span> <span class="c1"># = #projective spaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># = #hyper surfaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimA</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimA</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)])</span>

        <span class="c1"># check if actually CICY</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstchernvector</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">fc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The configuration matrix does not belong to a Calabi Yau. &#39;</span><span class="o">+</span>
                    <span class="s1">&#39;Its first Chern class is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fc</span><span class="p">))</span>

        <span class="c1">#some topological quantities, which we only want to calculate once</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">euler</span> <span class="o">=</span> <span class="s1">&#39;not defined&#39;</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">triple</span> <span class="o">=</span> <span class="s1">&#39;not defined&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quadruple</span> <span class="o">=</span> <span class="s1">&#39;not defined&#39;</span>
        <span class="c1"># need to define before hodge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fav</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># defining normal bundle sections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pmoduli</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">moduli</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_moduli</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> 
        
        <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hodge_data</span><span class="p">()</span>
        <span class="c1">#&#39;not defined&#39;</span>

        <span class="c1"># check if favourable, since needed for theorems in line_co</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fav</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fav</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fav</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fav</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span> <span class="o">==</span> <span class="mi">20</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fav</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="o">=</span> <span class="n">doc</span>

        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initialization took:&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>

        <span class="c1"># artifacts from debugging; might be useful if you want to change some code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;/&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="CICY.info"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints a broad overview of the geometric properties into the console.</span>
<span class="sd">        Includes: Configuration matrix, Hodge diamond, triple intersection</span>
<span class="sd">        numbers, Chern classes, Euler characteristic and defining</span>
<span class="sd">        Polynomials.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make this nice</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;has the following configuration matrix:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Its Hodge numbers are&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hodge_numbers</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The triple intersetion numbers are&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drstmatrix</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;and thus the second Chern class can be expressed as&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">secondchernvector</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The euler characteristic is&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eulerc</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The defining polynomials have been choosen to be&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">def_poly</span><span class="p">())</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;has the following configuration matrix:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Its Hodge numbers are&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hodge_numbers</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The quadruple intersetion numbers are&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drstumatrix</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The euler characteristic is&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eulerc</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The defining polynomials have been choosen to be&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">def_poly</span><span class="p">())</span></div>

<div class="viewcode-block" id="CICY.help"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.help">[docs]</a>    <span class="k">def</span> <span class="nf">help</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints an incomplete list of supported functions into the console.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Currently the following functions are supported:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;info() - for an overview of geometric data.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hodge_numbers() - for printing out the hodge numbers.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;def_poly() -  returns the defining polynomials.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;secondchernvector() - returns the second Chern class as a vector.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;thirdchernarray() - returns the third Chern class as a nested list.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fourthchernall() - returns the fourth Chern class as a nested list.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;drst(r,s,t) - returns a single triple intersection number.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;drstu(r,s,t,u) - returns a single quadruple intersection number.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;drstmatrix() - returns all triple intersection numbers as a nested list.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;drstumatrix() - returns all quadruple intersection numbers as a nested list.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;eulerc() - returns the Euler characteristic.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hodge_data() - determines the hodge data.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;line_co_euler(L) - returns the euler characteristic of a l.b. L over X.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;line_co(L) - returns the l.b. cohom. of L over X.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;l_slope(L) - returns whether an l.b. L is stable and the constraint as a tuple.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;is_directproduct() - determines whether M is a direct product or not.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;is_favourable() - returns if favourable or not.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CICY.hodge_numbers"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.hodge_numbers">[docs]</a>    <span class="k">def</span> <span class="nf">hodge_numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints the hodge numbers into the console, only supported for</span>
<span class="sd">        2,3,4 folds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;h^{1,1} = 20&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;h^{1,1} = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;h^{2,1} = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;h^{1,1} = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;h^{2,1} = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;h^{2,2} = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">4</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;h^{3,1} = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span></div>

<div class="viewcode-block" id="CICY.def_poly"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.def_poly">[docs]</a>    <span class="k">def</span> <span class="nf">def_poly</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the defining polynomials with (redundant) complex moduli as coefficients.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        normal: list/sympyexpr</span>
<span class="sd">            A list of the normal sections in terms of monomials.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;quintic&#39;, [[4,5]])</span>
<span class="sd">        &gt;&gt;&gt; M.def_poly()</span>
<span class="sd">        [45*x0**5 + 50*x0**4*x1 + ... + 40*x3*x4**4 + 30*x4**5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)]</span>
        <span class="n">projx</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x0:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimA</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">),</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># run over all normal bundle sections</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
            <span class="c1"># run over all monomials</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moduli</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="c1"># define monomials</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moduli</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimA</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                    <span class="n">tmp</span> <span class="o">*=</span> <span class="n">projx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">pmoduli</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
                <span class="c1"># add it to the respective entry</span>
                <span class="n">normal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmp</span>
        <span class="k">return</span> <span class="n">normal</span></div>

<div class="viewcode-block" id="CICY.firstchern"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.firstchern">[docs]</a>    <span class="k">def</span> <span class="nf">firstchern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the first Chern class corresponding to J_r, via</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{align}</span>
<span class="sd">            c_1^r &amp;= \bigg[ n_r +1 - \sum_{a=1}^{K} q_a^r \bigg].</span>
<span class="sd">            \end{align}</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        r : int</span>
<span class="sd">            the index of J_r.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        c1: int</span>
<span class="sd">            The first Chern class corresponding to J_r.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        firstchernvector: All first Chern classes.</span>
<span class="sd">        secondchern: Second Chern class of J_r, J_s.</span>
<span class="sd">        thirdchern: Third Chern class of J_r, J_s, J_t.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.firstchern(0)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">c1</span></div>

<div class="viewcode-block" id="CICY.firstchernvector"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.firstchernvector">[docs]</a>    <span class="k">def</span> <span class="nf">firstchernvector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the full first Chern class.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vector: array[nProj]</span>
<span class="sd">            The full firt Chern class for all J_r.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        firstchern: First Chern class of J_r.</span>
<span class="sd">        secondchern: Second Chern class of J_r, J_s.</span>
<span class="sd">        thirdchern: Third Chern class of J_r, J_s, J_t.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.firstchernvector()</span>
<span class="sd">        [0,0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">firstchern</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">vector</span></div>

<div class="viewcode-block" id="CICY.secondchern"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.secondchern">[docs]</a>    <span class="k">def</span> <span class="nf">secondchern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the second Chern class corresponding to J_r, J_s, via</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{align}</span>
<span class="sd">            c_2^{rs}  =\frac{1}{2} \bigg[ - \delta^{rs} (n_r + 1 ) + \sum_{a=1}^{K} q_a^r q_a^s \bigg].</span>
<span class="sd">            \end{align}</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        r : int</span>
<span class="sd">            the index of J_r.</span>
<span class="sd">        s : int</span>
<span class="sd">            the index of J_s.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        c2: float</span>
<span class="sd">            The second Chern class corresponding to J_r, J_s.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        firstchern: First Chern class of J_r.</span>
<span class="sd">        secondchernmatrix: All second Chern classes.</span>
<span class="sd">        secondchernvector: Second Chern class as a vector using triple intersection numbers.</span>
<span class="sd">        thirdchern: Third Chern class of J_r, J_s, J_t.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.secondchern(0,1)</span>
<span class="sd">        2.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sumqq</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">==</span><span class="n">s</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">c2</span> <span class="o">=</span><span class="p">(</span><span class="n">sumqq</span><span class="o">-</span><span class="n">delta</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="c1">#Calabi-Yau</span>
        <span class="c1">#c2 = ((sumqq-delta)+(firstchern(M,r)*firstchern(M,s)))/2 #non Calabi-Yau</span>
        <span class="k">return</span> <span class="n">c2</span></div>

<div class="viewcode-block" id="CICY.secondchernmatrix"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.secondchernmatrix">[docs]</a>    <span class="k">def</span> <span class="nf">secondchernmatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines all second Chern classes in a matrix.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matrix: array[nProj, nProj]</span>
<span class="sd">            The full second Chern class.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        firstchern: First Chern class of J_r.</span>
<span class="sd">        secondchern: Second Chern class of J_r, J_s.</span>
<span class="sd">        secondchernvector: Second Chern class as a vector using triple intersection numbers.</span>
<span class="sd">        thirdchern: Third Chern class of J_r, J_s, J_t.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.secondchernmatrix()</span>
<span class="sd">        [[1.0, 2.5], [2.5, 3.0]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">secondchern</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">matrix</span></div>

<div class="viewcode-block" id="CICY.thirdchern"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.thirdchern">[docs]</a>    <span class="k">def</span> <span class="nf">thirdchern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the third Chern class corresponding to J_r, J_s, J_t, via</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{align}</span>
<span class="sd">            c_3^{rst}  = \frac{1}{3} \bigg[ \delta^{rst} (n_r + 1 ) - \sum_{a=1}^{K} q_a^r q_a^s q_a^t \bigg].</span>
<span class="sd">            \end{align}</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        r : int</span>
<span class="sd">            the index of J_r.</span>
<span class="sd">        s : int</span>
<span class="sd">            the index of J_s.</span>
<span class="sd">        t : int</span>
<span class="sd">            the index of J_t.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        c3: float</span>
<span class="sd">            The third Chern class corresponding to J_r, J_s, J_t.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        firstchern: First Chern class of J_r.</span>
<span class="sd">        secondchern: Second Chern class of J_r, J_s.</span>
<span class="sd">        thirdchernarray: Complete third Chern class.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.thirdchern(0,1,1)</span>
<span class="sd">        -3.6666666666666665</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sumqqq</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">==</span><span class="n">s</span> <span class="ow">and</span> <span class="n">r</span><span class="o">==</span><span class="n">t</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">c3</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta</span><span class="o">-</span><span class="n">sumqqq</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span> <span class="c1"># Calabi Yau</span>
        <span class="c1">#c3 = ((delta-sumqqq)-</span>
        <span class="c1">#(secondchern(M,r,s)*firstchern(M,t)+secondchern(M,s,t)*firstchern(M,r)+secondchern(M,t,r)*firstchern(M,s))</span>
        <span class="c1">#+(firstchern(M,r)*firstchern(M,s)*firstchern(M,t)))/6 #for non Calabi Yau</span>
        <span class="k">return</span> <span class="n">c3</span></div>
        
<div class="viewcode-block" id="CICY.thirdchernarray"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.thirdchernarray">[docs]</a>    <span class="k">def</span> <span class="nf">thirdchernarray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines all third Chern classes in a nested list.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matrix: array[nProj, nProj, nProj]</span>
<span class="sd">            The full third Chern class.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        firstchern: First Chern class of J_r.</span>
<span class="sd">        secondchern: Second Chern class of J_r, J_s.</span>
<span class="sd">        thirdchern: Third Chern class of J_r, J_s, J_t.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.thirdchernarray()</span>
<span class="sd">        [[[-2.0, -2.3333333333333335], [-2.3333333333333335, -3.6666666666666665]], [[-2.3333333333333335, -3.6666666666666665], [-3.6666666666666665, -8.0]]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="p">[[[</span><span class="bp">self</span><span class="o">.</span><span class="n">thirdchern</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">matrix</span></div>

<div class="viewcode-block" id="CICY.fourthchern"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.fourthchern">[docs]</a>    <span class="k">def</span> <span class="nf">fourthchern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the fourth Chern class J_r, J_s, J_t, J_u for Calabi Yau four folds</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{align}</span>
<span class="sd">            c_4^{rstu}  = \frac{1}{4} \bigg[ - \delta^{rstu} (n_r + 1 ) + \sum_{a=1}^{K} q_a^r q_a^s q_a^t q_a^u + 2 c_2^{rs} c_2^{tu} \bigg].</span>
<span class="sd">            \end{align}</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        r : int</span>
<span class="sd">            the index of J_r.</span>
<span class="sd">        s : int</span>
<span class="sd">            the index of J_s.</span>
<span class="sd">        t : int</span>
<span class="sd">            the index of J_t.</span>
<span class="sd">        u : int</span>
<span class="sd">            the index of J_u.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        c4: float</span>
<span class="sd">            The fourth Chern class corresponding to J_r, J_s, J_t, J_u.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Exception</span>
<span class="sd">            If the Calabi Yau is smaller than a four fold.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        firstchern: First Chern class of J_r.</span>
<span class="sd">        secondchern: Second Chern class of J_r, J_s.</span>
<span class="sd">        thirdchern: Third Chern class of J_r, J_s, J_t.</span>
<span class="sd">        fourthchernall: All fourth Chern classes.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;4fold&#39;, [[2,3],[2,3],[1,2]])</span>
<span class="sd">        &gt;&gt;&gt; M.fourthchern(0,1,1,2)</span>
<span class="sd">        20.25</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] All CICY four-folds, by J. Gray, A. Haupt and A. Lukas.</span>
<span class="sd">            https://arxiv.org/pdf/1303.1832.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39; is a Calabai Yau 3fold.&#39;</span><span class="p">)</span>
        
        <span class="n">sumqqqq</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">==</span><span class="n">s</span> <span class="ow">and</span> <span class="n">r</span><span class="o">==</span><span class="n">t</span> <span class="ow">and</span> <span class="n">r</span><span class="o">==</span><span class="n">u</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">second</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">secondchern</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">secondchern</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>
        <span class="n">c4</span> <span class="o">=</span> <span class="p">(</span><span class="n">sumqqqq</span><span class="o">+</span><span class="n">second</span><span class="o">-</span><span class="n">delta</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span>
        <span class="k">return</span> <span class="n">c4</span></div>

<div class="viewcode-block" id="CICY.fourthchernall"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.fourthchernall">[docs]</a>    <span class="k">def</span> <span class="nf">fourthchernall</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines all fourth Chern classes in a nested list.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matrix: array[nProj, nProj, nProj, nProj]</span>
<span class="sd">            The full fourth Chern class.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        firstchern: First Chern class of J_r.</span>
<span class="sd">        secondchern: Second Chern class of J_r, J_s.</span>
<span class="sd">        thirdchern: Third Chern class of J_r, J_s, J_t.</span>
<span class="sd">        fourthchern: Foruth Chern class of J_r, J_s, J_t, J_u.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;4fold&#39;, [[2,3],[2,3],[1,2]])</span>
<span class="sd">        &gt;&gt;&gt; M.fourthchernall()</span>
<span class="sd">        [[[[24.0, 27.0, 18.0], [27.0, 24.75, 18.0], [18.0, 18.0, 10.5]], ... , [[10.5, 11.25, 7.5], [11.25, 10.5, 7.5], [7.5, 7.5, 4.0]]]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="p">[[[[</span><span class="bp">self</span><span class="o">.</span><span class="n">fourthchern</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span>
                     <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">matrix</span></div>

<div class="viewcode-block" id="CICY.drst"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.drst">[docs]</a>    <span class="k">def</span> <span class="nf">drst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the triple intersection number d_rst.</span>
<span class="sd">        We use:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{align}</span>
<span class="sd">             d_{rst} = \int_X J_r \wedge J_s \wedge J_t = \int_A \mu \wedge J_r \wedge J_s \wedge J_t </span>
<span class="sd">            \end{align}</span>

<span class="sd">        where \mu is the top form</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{align}</span>
<span class="sd">            \mu = \bigwedge^K_{a=1} \left(  \sum_{p=1}^{m} q_a^p J_p  \right) \; .</span>
<span class="sd">            \end{align}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        r : int</span>
<span class="sd">            index r.</span>
<span class="sd">        s : int</span>
<span class="sd">            index s.</span>
<span class="sd">        t : int </span>
<span class="sd">            index t.</span>
<span class="sd">        x : int, optional</span>
<span class="sd">            Normalization for integral, by default 1.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        drst: float</span>
<span class="sd">            Returns the triple intersection number drst.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Exception</span>
<span class="sd">            Only defined for Calabi Yau threefolds.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        drstmatrix: Determines all triple intersection numbers.</span>
<span class="sd">        secondchernvector: The second Chern class as a vector.</span>
<span class="sd">        eulerc: The eulercharacteristic.</span>
<span class="sd">        drstu: The quadruple intersection numbers for a four fold.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.drst(0,1,1)</span>
<span class="sd">        7.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#if self.nfold != 3:</span>
        <span class="c1">#    raise Exception(&#39;Only defined for 3 folds.&#39;)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">triple</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">triple</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">s</span><span class="p">][</span><span class="n">t</span><span class="p">]</span>
        <span class="n">drst</span><span class="o">=</span><span class="mi">0</span>
        <span class="c1"># Define the relevant part of \mu := \wedge^K_j \sum_r q_r^j J_r</span>
        <span class="n">combination</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)])</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span>
        <span class="c1">#now there are 5 distinct cases:</span>
        <span class="c1">#1) r=s=t or 2) all neqal or the 2-5) three cases where two are equal</span>
        <span class="c1">#1)</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">==</span><span class="n">s</span><span class="o">==</span><span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1">#then drst is zero</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
                <span class="c1">#now we want to fill combination and run over all m Projective spaces,</span>
                <span class="c1"># and how often they occur</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="n">r</span><span class="p">:</span>
                        <span class="c1">#we obviously have to subtract 3 in the case of three</span>
                        <span class="c1"># times the same index since we already have three kähler forms</span>
                        <span class="c1"># in Ambient space coming from the intersection number</span>
                        <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">3</span>
                        <span class="n">combination</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">3</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">combination</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># 2)                             </span>
        <span class="k">if</span> <span class="n">r</span><span class="o">!=</span><span class="n">s</span> <span class="ow">and</span> <span class="n">r</span><span class="o">!=</span><span class="n">t</span> <span class="ow">and</span> <span class="n">s</span><span class="o">!=</span><span class="n">t</span><span class="p">:</span>
            <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="n">r</span> <span class="ow">or</span> <span class="n">j</span><span class="o">==</span><span class="n">s</span> <span class="ow">or</span> <span class="n">j</span><span class="o">==</span><span class="n">t</span><span class="p">:</span>
                    <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
                    <span class="n">combination</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">combination</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># 3)</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">==</span><span class="n">s</span> <span class="ow">and</span> <span class="n">r</span><span class="o">!=</span><span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="n">r</span><span class="p">:</span>
                        <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span>
                        <span class="n">combination</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="n">t</span><span class="p">:</span>
                            <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
                            <span class="n">combination</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">combination</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># 4)</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">==</span><span class="n">t</span> <span class="ow">and</span> <span class="n">r</span><span class="o">!=</span><span class="n">s</span><span class="p">:</span>
            <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="n">r</span><span class="p">:</span>
                        <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span>
                        <span class="n">combination</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="n">s</span><span class="p">:</span>
                            <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
                            <span class="n">combination</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">combination</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># 5)</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">==</span><span class="n">t</span> <span class="ow">and</span> <span class="n">s</span><span class="o">!=</span><span class="n">r</span><span class="p">:</span>
            <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="n">s</span><span class="p">:</span>
                        <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span>
                        <span class="n">combination</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="n">r</span><span class="p">:</span>
                            <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
                            <span class="n">combination</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">combination</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># the combinations of mu grow exponentially with self.K and the number of ambient spaces</span>
        <span class="c1"># Check, when the number of multiset_permutations become to large to handle</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">combination</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
            <span class="c1"># Hence, for large K and small, this might take really long. </span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">iterables</span><span class="o">.</span><span class="n">multiset_permutations</span><span class="p">(</span><span class="n">combination</span><span class="p">)</span>
            <span class="c1"># self.K!/(#x_1!*...*#x_n!)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mu</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">x</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">drst</span> <span class="o">+=</span> <span class="n">v</span>
            <span class="k">return</span> <span class="n">drst</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># here we calculate the nonzero paths through the CICY</span>
            <span class="n">nonzero</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)]</span>
            <span class="n">combination</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">combination</span><span class="p">)</span>
            <span class="n">count_2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span>
            <span class="c1"># run over all K to find possible paths</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                    <span class="c1"># possible paths are non zero and in combination</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">combination</span><span class="p">:</span>
                        <span class="n">nonzero</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">count_2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Next we run over all entries in count to see if any are fixed by number of occurence</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">count_2</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="c1"># if equal we run over all entries in nonzero</span>
                    <span class="c1">#count[i] = 0</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
                        <span class="c1"># and fix them to i if they contain it </span>
                        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nonzero</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                            <span class="c1"># and len(nonzero[j]) != 1</span>
                            <span class="n">nonzero</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1">#There are some improvements here:</span>
            <span class="c1">#1) take the counts -= 1 if fixed and compare if the left allowed</span>
            <span class="c1">#2) here it would be even more efficient to write a product that respects </span>
            <span class="c1">#   the allowed combinations from count, but I can&#39;t be bothered to do it atm.</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">nonzero</span><span class="p">)</span>
            <span class="c1"># len(nonzero[0])*...*len(nonzero[K])</span>
            <span class="c1"># since we in principle know the complexity here and from the other</span>
            <span class="c1"># one could also do all the stuff before and then decide which way is faster</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mu</span><span class="p">:</span>
                <span class="c1"># if allowed by count</span>
                <span class="n">c</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">combination</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">x</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">v</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">drst</span> <span class="o">+=</span> <span class="n">v</span>
            <span class="k">return</span> <span class="n">drst</span></div>

<div class="viewcode-block" id="CICY.drstmatrix"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.drstmatrix">[docs]</a>    <span class="k">def</span> <span class="nf">drstmatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines all triple intersection numbers.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        d: array[nProj, nProj, nProj]</span>
<span class="sd">            numpy array of all triple intersection numbers, d_rst.</span>
<span class="sd">        </span>
<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        drst: Determines the triple intersection number d_rst.</span>
<span class="sd">        secondchernvector: The second Chern class as a vector.</span>
<span class="sd">        eulerc: The eulercharacteristic.</span>
<span class="sd">        drstu: The quadruple intersection numbers for a four fold.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.drstmatrix()</span>
<span class="sd">        array([[[0., 3.],</span>
<span class="sd">                [3., 7.]],</span>
<span class="sd">               [[3., 7.],</span>
<span class="sd">                [7., 2.]]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#if self.nfold != 3:</span>
        <span class="c1">#    raise Exception(&#39;Only defined for 3 folds.&#39;)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">triple</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">triple</span>
        <span class="c1"># Since the calculation of drst for large K becomes very tedious</span>
        <span class="c1"># we make use of symmetries</span>
        <span class="n">comb</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations_with_replacement</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">:</span>
            <span class="n">drst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drst</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">entries</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="c1"># there will be some redundant elements,</span>
            <span class="c1"># but they will only have to be calculated once.</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">drst</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">triple</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="CICY.secondchernvector"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.secondchernvector">[docs]</a>    <span class="k">def</span> <span class="nf">secondchernvector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses the triple intersection numbers to contract the second chern matrix to a vector:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{align}</span>
<span class="sd">             c_{2;t} = d_{rst} c_2^{rs}.</span>
<span class="sd">            \end{align}</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        chern: array[nProj]</span>
<span class="sd">            The second Chern class as a vector.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        drst: Determines the triple intersection number d_rst.</span>
<span class="sd">        secondchern: The second Chern class of J_r, J_s.</span>
<span class="sd">        secondchernmatrix: All second Chern classes.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.secondchernvector()</span>
<span class="sd">        [36.0, 44.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chern</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drstmatrix</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                    <span class="c1">#chern[i] += self.drst(i,j,k,1)*self.secondchern(j,k)</span>
                    <span class="n">chern</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">secondchern</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chern</span></div>

<div class="viewcode-block" id="CICY.drstu"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.drstu">[docs]</a>    <span class="k">def</span> <span class="nf">drstu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the quadruple intersection numbers, d_rstu, for Calabi Yau four folds.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        r : int</span>
<span class="sd">            the index r.</span>
<span class="sd">        s : int</span>
<span class="sd">            the index s.</span>
<span class="sd">        t : int</span>
<span class="sd">            the index t.</span>
<span class="sd">        u : int</span>
<span class="sd">            the index u.</span>
<span class="sd">        x : int, optional</span>
<span class="sd">            Normalization for integral, by default 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        drstu: float</span>
<span class="sd">            The quadruple intersection number d_rstu.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Exception</span>
<span class="sd">            If the Calabi Yau is smaller than a four fold.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        drst: Determines the triple intersection number d_rst.</span>
<span class="sd">        eulerc: The eulercharacteristic.</span>
<span class="sd">        drstumatrix: All quadruple intersection numbers of a four fold.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;4fold&#39;, [[2,3],[2,3],[1,2]])</span>
<span class="sd">        &gt;&gt;&gt; M.drstu(0,1,1,2)</span>
<span class="sd">        3</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] All CICY four-folds, by J. Gray, A. Haupt and A. Lukas.</span>
<span class="sd">            https://arxiv.org/pdf/1303.1832.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#if self.nfold != 4:</span>
        <span class="c1">#    raise Exception(&#39;Only defined for 4 folds.&#39;)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quadruple</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadruple</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">s</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">u</span><span class="p">]</span>
        <span class="n">drstu</span><span class="o">=</span><span class="mi">0</span>
        <span class="c1"># Define the relevant part of \mu := \wedge^K_j \sum_r q_r^j J_r</span>
        <span class="n">combination</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)])</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span>
        <span class="c1">#now there are 5 distinct cases:</span>
        <span class="c1">#1) r=s=t=u or 2) all neqal or the 3) two equal, two nonequal</span>
        <span class="c1">#4) two equal and two equal 5) three equal</span>
        <span class="n">un</span><span class="p">,</span> <span class="n">unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">u</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">un</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">un</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">unc</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
            <span class="c1">#if j in rstu subtract</span>
            <span class="c1"># else go full</span>
            <span class="n">contained</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">un</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">un</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span>
                    <span class="n">contained</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">unc</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
                    <span class="n">combination</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">unc</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">contained</span><span class="p">:</span>
                <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">combination</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">unc</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="c1"># just copy from drst</span>
        <span class="c1"># the combinations of mu grow exponentially with self.K and the number of ambient spaces</span>
        <span class="c1"># Check, when the number of multiset_permutations become to large to handle</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">combination</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
            <span class="c1"># Hence, for large K and small, this might take really long. </span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">iterables</span><span class="o">.</span><span class="n">multiset_permutations</span><span class="p">(</span><span class="n">combination</span><span class="p">)</span>
            <span class="c1"># self.K!/(#x_1!*...*#x_n!)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mu</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">x</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">drstu</span> <span class="o">+=</span> <span class="n">v</span>
            <span class="k">return</span> <span class="n">drstu</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># here we calculate the nonzero paths through the CICY</span>
            <span class="n">nonzero</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)]</span>
            <span class="n">combination</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">combination</span><span class="p">)</span>
            <span class="n">count_2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span>
            <span class="c1"># run over all K to find possible paths</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                    <span class="c1"># possible paths are non zero and in combination</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">combination</span><span class="p">:</span>
                        <span class="n">nonzero</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">count_2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Next we run over all entries in count to see if any are fixed by number of occurence</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">count_2</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="c1"># if equal we run over all entries in nonzero</span>
                    <span class="c1">#count[i] = 0</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
                        <span class="c1"># and fix them to i if they contain it </span>
                        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nonzero</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                            <span class="c1"># and len(nonzero[j]) != 1</span>
                            <span class="n">nonzero</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1">#There are some improvements here:</span>
            <span class="c1">#1) take the counts -= 1 if fixed and compare if the left allowed</span>
            <span class="c1">#2) here it would be even more efficient to write a product that respects </span>
            <span class="c1">#   the allowed combinations from count, but I can&#39;t be bothered to do it atm.</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">nonzero</span><span class="p">)</span>
            <span class="c1"># len(nonzero[0])*...*len(nonzero[K])</span>
            <span class="c1"># since we in principle know the complexity here and from the other</span>
            <span class="c1"># one should also do all the stuff before and then decide which way is faster</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mu</span><span class="p">:</span>
                <span class="c1"># if allowed by count</span>
                <span class="n">c</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">combination</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">x</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">v</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">drstu</span> <span class="o">+=</span> <span class="n">v</span>
            <span class="k">return</span> <span class="n">drstu</span></div>

<div class="viewcode-block" id="CICY.drstumatrix"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.drstumatrix">[docs]</a>    <span class="k">def</span> <span class="nf">drstumatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines all quadruple intersection numbers.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        d: array[nProj, nProj, nProj, nProj]</span>
<span class="sd">            numpy array of all quadruple intersection numbers, d_rstu.</span>
<span class="sd">        </span>
<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        drst: Determines the triple intersection number d_rst.</span>
<span class="sd">        eulerc: The eulercharacteristic.</span>
<span class="sd">        drst: The quadruple intersection number d_rstu for a four fold.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;4fold&#39;, [[2,3],[2,3],[1,2]])</span>
<span class="sd">        &gt;&gt;&gt; M.drstu(0,1,1,2)</span>
<span class="sd">        array([[[[0., 0., 0.],</span>
<span class="sd">                 [0., 2., 3.],</span>
<span class="sd">                 [0., 3., 0.]],</span>
<span class="sd">                    ...</span>
<span class="sd">                [[0., 0., 0.],</span>
<span class="sd">                 [0., 0., 0.],</span>
<span class="sd">                 [0., 0., 0.]]]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quadruple</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadruple</span>
        <span class="c1"># Since the calculation of drstu for large K becomes very tedious</span>
        <span class="c1"># we make use of symmetries</span>
        <span class="n">comb</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations_with_replacement</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">:</span>
            <span class="n">drstu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drstu</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">entries</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="c1"># there will be some redundant elements,</span>
            <span class="c1"># but they will only have to be calculated once.</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">drstu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quadruple</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="CICY.eulerc"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.eulerc">[docs]</a>    <span class="k">def</span> <span class="nf">eulerc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the Euler characteristic via integration of the Chern class. Take e.g. n=3</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{align}</span>
<span class="sd">             \chi = \frac{1}{2} \int_X c_3 \; .</span>
<span class="sd">            \end{align}</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        e: float</span>
<span class="sd">            The euler characteristic.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        drst: Determines the triple intersection number d_rst.</span>
<span class="sd">        thirdchern: The third Chern class of J_r, J_s, J_t.</span>
<span class="sd">        drstu: The quadruple intersection number d_rstu for a four fold.</span>
<span class="sd">        fourthchern: The fourth Chern class of J_r, J_s, J_t, J_u.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.eulerc()</span>
<span class="sd">        -114.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">euler</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler</span>
        <span class="n">e</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drstmatrix</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                        <span class="c1">#e += self.drst(i,j,k,self.thirdchern(i,j,k))</span>
                        <span class="n">e</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">thirdchern</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drstumatrix</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                            <span class="n">e</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fourthchern</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="mi">24</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">euler</span> <span class="o">=</span> <span class="n">e</span>
        <span class="c1">#int(e) makes 0.9999 float to 0 which comes from the third Chern,</span>
        <span class="c1"># hence we use round</span>
        <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_fill_moduli</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determines a tuple with monomials and their (redundant) complex moduli</span>
<span class="sd">             as coefficient for the defining Normal sections.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            seed (int): Random seed for the coefficients</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple </span>
<span class="sd">                1: (nested list: int): nested list of all monomials</span>
<span class="sd">                2: (nested list: int): nested list of all coefficients</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="c1"># find the sections of the normal</span>
        <span class="n">sec_norm</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="c1"># declare return lists</span>
        <span class="n">pmoduli</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)]</span>
        <span class="n">moduli</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)]</span>
        <span class="c1">#fill them</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_brackets_dim</span><span class="p">(</span><span class="n">sec_norm</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">pmoduli</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_makepoly</span><span class="p">(</span><span class="n">sec_norm</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dim</span><span class="p">)</span>
            <span class="c1"># fill with random values, generic polynomials</span>
            <span class="c1"># could make it optional to give the range of the values</span>
            <span class="n">moduli</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pmoduli</span><span class="p">,</span> <span class="n">moduli</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_BBW</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Applies the BBW theorem to a Vector bundle in BBW notation.</span>
<span class="sd">           Schematic calculation follows:</span>
<span class="sd">                (1|-101) -&gt; (2135) -&gt; (1235) -&gt; [[0,0,0,1],j=1]</span>
<span class="sd">           Returns the new vector notation and value for j = # of swaps.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            V (nested list: int): A vector bundle in BBW notation, see example</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (nested list: int): Returns a list with transformed vector in BBW notation and non zero cohomology;</span>
<span class="sd">                                    or [0,500] in case of vanishing cohomology.</span>

<span class="sd">        Example:</span>
<span class="sd">            O(2) over P^1:</span>
<span class="sd">              &gt;&gt;&gt; BBW([2,0])</span>
<span class="sd">              [[1,2], 1]</span>
<span class="sd">            or</span>
<span class="sd">              &gt;&gt;&gt; BBW([1,-1,0,1])</span>
<span class="sd">              [[0,0,0,1],1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># input + sequence</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="p">[</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">))]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># permutations</span>
        <span class="n">save</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">))]</span>
        <span class="c1"># Next we run over V and sort it according to BBW</span>
        <span class="c1"># essentially bubblesort?</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># if two entries are the same -&gt; return zero</span>
                <span class="k">if</span> <span class="n">vector</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">vector</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># if n &gt; n+1 then we interchange and add +1 to j</span>
                    <span class="k">if</span> <span class="n">vector</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">vector</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">save</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                        <span class="n">vector</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">vector</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">save</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span>
        <span class="c1"># Now that we have sorted the vector, we need to subtract the sequence</span>
        <span class="n">save</span> <span class="o">=</span> <span class="p">[</span><span class="n">vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">))]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">save</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_hom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Determines the nonzero entries in the first Leray instance.</span>
<span class="sd">           This is achieved by calculating all vector bundles resulting from</span>
<span class="sd">           \wedge^k N \otimes V .</span>
<span class="sd">           Returns then a list of all surviving representations and their origin.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            V (nested list: int): Vector bundle in BBW notation</span>
<span class="sd">            k (int): \wedge^k k-th wedge product of the Normalbundle.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple</span>
<span class="sd">                1. (nested list: int): [BBW notation after BBW, j]</span>
<span class="sd">                2. (nested list: int): list of integers indicating the Normal bundle origin of each entry</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; M.hom([324], 2)</span>
<span class="sd">             </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We begin by finding the amount of possible combinations coming from k</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">binom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>

        <span class="c1"># Next, we create a new matrix for the wedge products</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
        <span class="c1"># and the origins</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>

        <span class="c1"># We fill the matrix with the #k=x combinations</span>
        <span class="c1"># Since the normal bundle consists of line bundles we only save the total</span>
        <span class="c1"># integer for each combination</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
            <span class="c1"># We create a list saving the combinations of N[a] as (A,B), (A,C),..</span>
            <span class="n">combvector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">k</span><span class="p">))</span>
            <span class="n">originvector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">([</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)],</span> <span class="n">k</span><span class="p">))</span>
            <span class="c1"># Next we need to determine the (wedge) products of all these x combinations</span>
            <span class="c1"># For that we take the sum of all entries in combvector</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">a</span><span class="p">]</span><span class="o">+</span><span class="n">combvector</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
                <span class="n">origin</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">originvector</span><span class="p">[</span><span class="n">b</span><span class="p">][:]</span>
        
        <span class="c1"># Next we need to transform the integer in a valid vector notation for</span>
        <span class="c1"># BBW to work with and add the vector which cohomology we are interested in</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="c1"># each integer becomes a vector of length corresponding projective</span>
                <span class="c1"># space + 1, where the integer is the first entry</span>
                <span class="c1"># Introduce save</span>
                <span class="n">save</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">a</span><span class="p">]</span>
                <span class="c1"># add/substract the vector</span>
                <span class="c1"># Here the code made a ref, be careful</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">a</span><span class="p">][:]</span>
                <span class="c1"># add to the first element our saved integer</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">save</span>
        
        <span class="c1"># We should now have a matrix with representations which we can feed into</span>
        <span class="c1"># BBW. BBW will then return, a cohomology and a value j, which are non zero</span>
        <span class="n">Bott</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                <span class="n">save</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BBW</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">a</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">save</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">500</span><span class="p">:</span>
                    <span class="c1"># This means that this whole [b] entry should be zero</span>
                    <span class="n">Bott</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="c1"># we need to end the [a] loop and go to the next [b]</span>
                    <span class="n">j</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="mi">500</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># it is not zero we simply set it equal to representation from BBW</span>
                    <span class="n">Bott</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">save</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">j</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">+</span><span class="n">save</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># and save the origin</span>
                    <span class="n">ob</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">origin</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">a</span><span class="p">]</span>
        <span class="c1"># We return a vector of cohomologies for each possible product-vector</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Bott</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">ob</span>

    <span class="k">def</span> <span class="nf">_brackets_dimv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determines the dimension of a vector bundle in bracket notation.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            B (nested list: int): Vector bundle in bracket notation.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (int): dimension of that Vector bundle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">abs</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">B</span><span class="p">]</span>
        <span class="c1"># loop over all projective spaces</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
            <span class="c1"># loop over all &#39;tensors&#39;</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">a</span><span class="p">])):</span> 
                <span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span><span class="o">*</span><span class="n">sc</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">binom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1">#since traceless subtract 1</span>
                <span class="n">dim</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_vector_brackets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Takes a vector(tangent ambient) bundle in BBW notation and</span>
<span class="sd">        transforms into Bracket notation.</span>
<span class="sd">        </span>
<span class="sd">        Follows schematically:</span>
<span class="sd">            (-1|01)        </span>
<span class="sd">            (-2|00 )  --&gt; [[1,-1],[2],[2]]</span>
<span class="sd">            (-2|000)</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            V (nested list: int): A vector bundle in BBW notation</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (nested list: int): A vector bundle in bracket notation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">brackets</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">))]</span>
        <span class="c1"># Now for line bundles there are two cases</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)):</span>
            <span class="c1">#If BBW flipped the dimension to the right,</span>
            <span class="c1">#  we have a 1 in first entry,</span>
            <span class="k">if</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># then we know that the important entries sit on the right end</span>
                <span class="c1"># we iterate over all and save all which are != 1</span>
                <span class="k">if</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                        <span class="k">if</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#if == 0 we have a &#39;scalar&#39;</span>
                <span class="k">if</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                            <span class="k">if</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># otherwise run over all and check all nonzero entries</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                        <span class="k">if</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])]</span>
        <span class="k">return</span> <span class="n">brackets</span>

<div class="viewcode-block" id="CICY.Leray"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.Leray">[docs]</a>    <span class="k">def</span> <span class="nf">Leray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the first instance, i=1, of a Leray table for a given vector bundle V.</span>

<span class="sd">        .. math::</span>

<span class="sd">            \begin{align}</span>
<span class="sd">	        E_{i+1}^{j,k} = \frac{\text{Ker}(d_i : E_{i}^{j,k} (\mathcal{V}) \rightarrow E_i^{j-1,k-1}(\mathcal{V}) )}{\text{Im}(d_i : E_{i}^{j+i-1,k+i} (\mathcal{V}) \rightarrow E_i^{j,k}(\mathcal{V}) )}</span>
<span class="sd">	        \end{align}</span>
<span class="sd">        </span>
<span class="sd">        V has to be in proper BBW notation, this is most easily achieved, by taking e.g. a line bundle L = [q_1 , ... ,q_n] and</span>

<span class="sd">        &gt;&gt;&gt; V = M._line_to_BBW(L)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        V : nested list</span>
<span class="sd">            A vector bundle in BBW notation.</span>
<span class="sd">        line : bool, optional</span>
<span class="sd">            True, if the vector bundle is a line bundle, by default True.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        E: nested list</span>
<span class="sd">            The first Leray instance</span>
<span class="sd">        origin: nested list</span>
<span class="sd">            The origin of each non trivial entry.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        line_co: Line bundle cohomology of L.</span>
<span class="sd">        _line_to_BBW: Transforms a line bundle into BBW notation.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; V = M._line_to_BBW([3,-4])</span>
<span class="sd">        &gt;&gt;&gt; M.Leray()</span>
<span class="sd">        ([[0, 0, 0, [[3, 0]], 0, 0], [0, 0, 0, [[1, -1], [2, -3]], 0, 0], [0, 0, 0, [[0, -4]], 0, 0]],</span>
<span class="sd">         [[0, 0, 0, 0, 0, 0], [0, 0, 0, [(0,), (1,)], 0, 0], [0, 0, 0, [(0, 1)], 0, 0]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Build Leray table E_1[k][j]</span>
        <span class="n">E</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimA</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="c1"># origin saves where the rep came from</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimA</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="c1"># First we fill k=0 since our other algorithm makes some problems there;</span>
        <span class="c1"># this will always be only one cohomology entry/ stacked list</span>
        <span class="n">E_0</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_BBW</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># we look if any of the stacked representations yields 0 --&gt; 0</span>
        <span class="c1"># if not we find the appropriate cohomology j value</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">E_0</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">500</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mi">500</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">E_0</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">500</span><span class="p">:</span>
            <span class="c1"># if cohomology is non zero we put it at the right j value</span>
            <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">E_0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="c1">#origin[0][x] = [0]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E_0</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># make line bracket notation</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_brackets</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vector_brackets</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># if cohomology is zero we simply leave all j for k=0 as zero.</span>
        <span class="c1"># Next we fill the higher entries of k</span>
        <span class="c1"># create a list which checks if cohomology class is non zero and saves</span>
        <span class="c1"># the cohomology rep in 1st and j in 2nd entry</span>
        <span class="c1"># Table = [[0, 500]]</span>
        <span class="c1"># Now we run a loop over all k entries and fill the table</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>  <span class="c1"># go over entries 1 to K</span>
            <span class="n">Table</span><span class="p">,</span> <span class="n">torigin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hom</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>  <span class="c1"># fill table with cohomology values</span>
            <span class="c1"># now we fill our leray table with all found cohomologies</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Table</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">Table</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">500</span><span class="p">:</span>  <span class="c1">#ask if cohomolgy changed, i.e. is non zero</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Table</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">a</span><span class="p">])</span>  <span class="c1"># extract j of cohomolgy</span>
                    <span class="c1"># Now we want to add those non zero cohomologies to our table</span>
                    <span class="k">if</span> <span class="n">E</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if it is the first non zero j, then equal</span>
                        <span class="c1">#E[k][x] = [Table[0][a]]# in BBW notation</span>
                        <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
                            <span class="n">E</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_line_brackets</span><span class="p">(</span><span class="n">Table</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">a</span><span class="p">])]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">E</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_vector_brackets</span><span class="p">(</span><span class="n">Table</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">a</span><span class="p">])]</span>
                        <span class="n">origin</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">torigin</span><span class="p">[</span><span class="n">a</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># if there is already a nonzero entry, we append</span>
                        <span class="c1">#E[k][x].append(Table[0][a])# in BBW</span>
                        <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
                            <span class="n">E</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_line_brackets</span><span class="p">(</span><span class="n">Table</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">a</span><span class="p">]))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">E</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vector_brackets</span><span class="p">(</span><span class="n">Table</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">a</span><span class="p">]))</span>
                        <span class="n">origin</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torigin</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">E</span><span class="p">,</span> <span class="n">origin</span></div>

    <span class="k">def</span> <span class="nf">_line_to_BBW</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transforms a line bundle into BBW notation.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            L (list: int): line bundle</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (nested list: int): line bundle in BBW notation</span>
<span class="sd">        </span>
<span class="sd">        Example:</span>
<span class="sd">            Consider a CICY X with ambient space P^1, P^2, P^3</span>
<span class="sd">            &gt;&gt; X._line_to_BBW([1,2,3])</span>
<span class="sd">             [[-1,0],[-2,0,0],[-3,0,0,0]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">linebundle</span> <span class="o">=</span> <span class="p">[[(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="n">a</span><span class="p">]]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span>
        <span class="c1"># Need a loop which adds 0 according to dim(P_a)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
            <span class="n">linebundle</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">linebundle</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span>
        <span class="k">return</span> <span class="n">linebundle</span>

    <span class="k">def</span> <span class="nf">_line_brackets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Takes a line bundle in BBW notation and transforms into bracket notation.</span>
<span class="sd">        </span>
<span class="sd">        Follows schematically:</span>
<span class="sd">            (-1|0  )</span>
<span class="sd">            (-2|00 )  --&gt; [1,2,2]</span>
<span class="sd">            (-2|000)</span>

<span class="sd">        Args:</span>
<span class="sd">            V (nested list: int): A line bundle in BBW notation</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (list: int): A line bundle in bracket notation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">brackets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">))]</span>
        <span class="c1"># Now for line bundles there are two cases</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)):</span>
            <span class="c1">#If BBW flipped the dimension to the right,</span>
            <span class="c1">#  we have a 1 in first entry,</span>
            <span class="k">if</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># then we assign the following value/degree of polynomial</span>
                <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#if != 1 then we haven&#39;t flipped at all in BBW,</span>
                <span class="c1">#  and we keep the value</span>
                <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">-</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">brackets</span>

    <span class="k">def</span> <span class="nf">_brackets_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determines the dimension of a line bundle in bracket notation.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            B (list: int): Line bundle in bracket notation.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (int): dimension of that line bundle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">B</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span> 
            <span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span><span class="o">*</span><span class="n">sc</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">binom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_lorigin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">or1</span><span class="p">,</span> <span class="n">or2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Takes two origins and returns a list of allowed mappings.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            or1 (list: int): Origins of the first bundle</span>
<span class="sd">            or2 (list: int): Origins of the second bundle</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (nested list): [[bool, int], ...] of allowed mappings and positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#run a loop over all entries in or2</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span><span class="p">,</span> <span class="mi">500</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">or2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">or2</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">or2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">or1</span><span class="p">)):</span>
                    <span class="n">origin</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">or1</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">or2</span><span class="p">[</span><span class="n">i</span><span class="p">])))[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">origin</span><span class="p">[</span><span class="n">or1</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">origin</span>

<div class="viewcode-block" id="CICY.hodge_data"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.hodge_data">[docs]</a>    <span class="k">def</span> <span class="nf">hodge_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the hodge numbers of the CICY. Based on Euler and adjunction sequence.</span>
<span class="sd">        I checked the results for all three folds against the ones found in the CICYlist.</span>
<span class="sd">        The computation of the four fold hodge numbers, however, has only been checked for some selected examples.</span>
<span class="sd">        Hence, the results should be taken with care and compared to the literature.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h: array[nfold+1]</span>
<span class="sd">            hodge numbers of the CICY.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Exception</span>
<span class="sd">            Only implemented for 2,3 and 4 folds.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        eulerc: Determines the euler characteristic</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.hodge_data()</span>
<span class="sd">        [0, 59, 2.0, 0]</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] CY - The Bestiary, T. Hubsch</span>
<span class="sd">            http://inspirehep.net/record/338506?ln=en</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># first we check if direct product</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">test</span><span class="p">,</span> <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_directproduct</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The configuration matrix corresponds to a direct product&#39;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
                    <span class="c1"># Apply Kunneth to get proper hodge data?</span>
                    <span class="k">return</span> <span class="n">h</span>
            <span class="c1"># we only need to determine h^21 or h^11 since they</span>
            <span class="c1"># are related via Euler characteristic</span>
            <span class="n">n_cod</span><span class="p">,</span> <span class="n">n_cos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)],</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)]</span>
            <span class="n">n_dim</span><span class="p">,</span> <span class="n">n_spa</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
                <span class="n">n_cod</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">n_cos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_co</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span> <span class="n">space</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">n_dim</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n_cod</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">n_cos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>
                        <span class="n">n_spa</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">n_cos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span>
            <span class="c1"># tangent bundle related cohomology</span>
            <span class="n">s_cod</span><span class="p">,</span> <span class="n">s_cos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)],</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span>
            <span class="n">s_dim</span><span class="p">,</span> <span class="n">s_spa</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                <span class="n">s_cod</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s_cos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_co</span><span class="p">([</span><span class="mi">0</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)],</span> <span class="n">space</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">s_dim</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">s_cod</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">s_cos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>
                        <span class="n">s_spa</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">s_cos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="c1">#[s_cos[i][j]]</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We find the following dimensions in the long exact cohomology sequence:&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;0 -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">s_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;h^{2,1} -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">s_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;h^{1,1} -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">s_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;0 -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">s_dim</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_dim</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>

            <span class="c1"># need to calculate kernel(H^1(X,S) -&gt; H^1(X,N))</span>
            <span class="k">if</span> <span class="n">n_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">kernel</span> <span class="o">=</span> <span class="n">s_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">s_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">kernel</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># generic surjective map, matches the results for all CICY threefolds in the literature</span>
                <span class="c1"># We don&#39;t really need the space then.</span>
                <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">s_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">n_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="c1"># fill in h^21=h1 and h^11=h2</span>
            <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">s_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="o">+</span><span class="n">kernel</span>
            <span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eulerc</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">h</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># first we check if direct product</span>
            <span class="n">test</span><span class="p">,</span> <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_directproduct</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The configuration matrix corresponds to a direct product&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
                <span class="c1"># Apply Kunneth?</span>
                <span class="k">return</span> <span class="n">h</span>
            <span class="c1"># we use the results from 1405.2073</span>
            <span class="c1"># euler = 4 +2h^11-4h^21+2h^31+h^22</span>
            <span class="c1"># -4h^11+2h^21-4h^31+h^22=44</span>
            <span class="n">n_cod</span><span class="p">,</span> <span class="n">n_cos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)],</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)]</span>
            <span class="n">n_dim</span><span class="p">,</span> <span class="n">n_spa</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
                <span class="n">n_cod</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">n_cos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_co</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span> <span class="n">space</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">n_dim</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n_cod</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">n_cos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>
                        <span class="n">n_spa</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">n_cos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span>

            <span class="n">s_cod</span><span class="p">,</span> <span class="n">s_cos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)],</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)]</span>
            <span class="n">s_dim</span><span class="p">,</span> <span class="n">s_spa</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                <span class="n">s_cod</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s_cos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_co</span><span class="p">([</span><span class="mi">0</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)],</span> <span class="n">space</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">s_dim</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">s_cod</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">s_cos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>
                        <span class="n">s_spa</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">s_cos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="c1">#[s_cos[i][j]]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We find the following dimensions in the long exact cohomology sequence:&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;0 -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">s_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;h^{3,1} -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">s_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;h^{2,1} -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">s_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;h^{1,1} -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">s_dim</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_dim</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;0 -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">s_dim</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; -&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_dim</span><span class="p">[</span><span class="mi">4</span><span class="p">]))</span>

            <span class="c1"># need to calculate kernel(H^1(X,S) -&gt; H^1(X,N))</span>
            <span class="k">if</span> <span class="n">n_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">kernel</span> <span class="o">=</span> <span class="n">s_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">s_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">kernel</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># surjective as for threefold</span>
                <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">s_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">n_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="c1"># fill in h^31=h1 and h^21=h2 and h^11 = h3 and </span>
            <span class="c1"># with some abuse of notation we redefine h4 := h^22 </span>
            <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">s_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="o">+</span><span class="n">kernel</span>
            <span class="c1"># check if the sequence splits anywhere</span>
            <span class="k">if</span> <span class="n">s_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="p">(</span><span class="n">s_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">kernel</span><span class="p">)</span>
                <span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eulerc</span><span class="p">()</span><span class="o">/</span><span class="mi">6</span><span class="o">+</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">8</span>
                <span class="n">h</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">44</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">n_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="p">(</span><span class="n">s_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">kernel</span><span class="p">)</span><span class="o">+</span><span class="n">s_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eulerc</span><span class="p">()</span><span class="o">/</span><span class="mi">6</span><span class="o">+</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">8</span>
                <span class="n">h</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">44</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># assume surjectiv again</span>
                <span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="p">(</span><span class="n">s_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">kernel</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">s_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">n_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
                <span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eulerc</span><span class="p">()</span><span class="o">/</span><span class="mi">6</span><span class="o">+</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">8</span>
                <span class="n">h</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">44</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">h</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># K3</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Hodge calculation is only implemented for n=2,3,4 CY folds.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CICY.is_favourable"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.is_favourable">[docs]</a>    <span class="k">def</span> <span class="nf">is_favourable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if the CICY is favourable, i.e.</span>
<span class="sd">        h^{1,1} = number of projective spaces.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.fav: bool</span>
<span class="sd">            True for favourable CICYs, False for non.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        is_directproduct: Determines if the CICY is a direct product.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.is_favourable()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fav</span></div>

<div class="viewcode-block" id="CICY.is_directproduct"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.is_directproduct">[docs]</a>    <span class="k">def</span> <span class="nf">is_directproduct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if a CICY is a direct product.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        direct: bool</span>
<span class="sd">            True if direct product, else False.</span>
<span class="sd">        product: list</span>
<span class="sd">            If direct == False, contains the components of the direct product and their position,</span>
<span class="sd">            else an empty list.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Exception</span>
<span class="sd">            If the configuration matrix contains a mistake.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        is_favourable: Determines if the CICY is favourable.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.is_directproduct()</span>
<span class="sd">        (False, []) </span>
<span class="sd">        &gt;&gt;&gt; D = CICY(&#39;TxK3&#39;, [[2,3,0],[3,0,4]])</span>
<span class="sd">        &gt;&gt;&gt; D.is_directproduct()</span>
<span class="sd">        (True, [[&#39;T&#39;, [0]], [&#39;K3&#39;, [1]]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">direct</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="n">product</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#1d check is easy</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">trans</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">trans</span><span class="p">[</span><span class="n">x</span><span class="p">]):</span>
                    <span class="c1"># then there is a direct product</span>
                    <span class="n">direct</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">trans</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="c1"># Torus</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">product</span> <span class="o">+=</span> <span class="p">[[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">]]]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;There must be a mistake in the configuration matrix: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">trans</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">direct</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="c1"># redundant or wrong CICY</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The CICY is redundant here: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">]))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;There must be a mistake in the configuration matrix: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">trans</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                        <span class="c1"># K3</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="n">product</span> <span class="o">+=</span> <span class="p">[[</span><span class="s1">&#39;K3&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">]]]</span>
                            <span class="c1"># if three fold we found K3xT</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                                <span class="k">return</span> <span class="n">direct</span><span class="p">,</span> <span class="n">product</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;There must be a mistake in the configuration matrix: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">trans</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                        <span class="c1"># Quintic</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                            <span class="n">product</span> <span class="o">+=</span> <span class="p">[[</span><span class="s1">&#39;Quintic&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">]]]</span>
                            <span class="c1"># if three fold we found Qunitic, else Quintic times Torus</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                                <span class="k">return</span> <span class="n">direct</span><span class="p">,</span> <span class="n">product</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                                <span class="n">direct</span> <span class="o">=</span> <span class="kc">False</span>
                                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Are you the Quintic?&#39;</span><span class="p">)</span>
                                <span class="k">return</span> <span class="n">direct</span><span class="p">,</span> <span class="n">product</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;There must be a mistake in the configuration matrix: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">]))</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        possible time efficiency improvement here</span>
<span class="sd">        # first we check if we found any products, then we should investigate the other factor</span>
<span class="sd">        if product != []:</span>
<span class="sd">            return direct, product</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # in principle we should check whether self.K or self.len is bigger</span>
<span class="sd">        # so that we work with less combinations. The implementation of both</span>
<span class="sd">        # is however slightly differnt and we stick to self.K, i.e. the normal sections.</span>
<span class="sd">        # check whether it is easier to work with transpose or normal</span>
<span class="sd">        if self.K &gt; self.len:</span>
<span class="sd">            l = self.K</span>
<span class="sd">            conf = np.sign(self.N)</span>
<span class="sd">        else:</span>
<span class="sd">            l = self.len</span>
<span class="sd">            conf = np.sign(trans)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#conf = np.sign(self.N)</span>
        <span class="c1">#loop over all combinations; start at i=1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">direct</span><span class="p">,</span> <span class="n">product</span>
            <span class="c1"># be careful this can also become quite large</span>
            <span class="n">combs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)],</span> <span class="n">i</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combs</span><span class="p">)):</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">[:,</span> <span class="n">combs</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">x1</span><span class="p">))</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">x2</span><span class="o">+</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">))):</span>
                    <span class="c1">#what product are we looking at?</span>
                    <span class="n">direct</span> <span class="o">=</span>  <span class="kc">True</span>
                    <span class="n">dim</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)</span> <span class="k">if</span> <span class="n">x1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">i</span>
                    <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">product</span> <span class="o">+=</span> <span class="p">[[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">combs</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span>
                    <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">product</span> <span class="o">+=</span> <span class="p">[[</span><span class="s1">&#39;K3&#39;</span><span class="p">,</span> <span class="n">combs</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span>
                    <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">product</span> <span class="o">+=</span> <span class="p">[[</span><span class="s1">&#39;CY3&#39;</span><span class="p">,</span> <span class="n">combs</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span>
        <span class="c1"># the returned product list might be redundant as TxT will also yield a &#39;K3&#39;, etc.</span>
        <span class="k">return</span> <span class="n">direct</span><span class="p">,</span> <span class="n">product</span></div>

    <span class="k">def</span> <span class="nf">_single_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">dim_V1</span><span class="p">,</span> <span class="n">V2</span><span class="p">,</span> <span class="n">dim_V2</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine the matrix of shape (dim_V2,dim_V1) for the map from V1 to V2.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            V1 (list: int): Line bundle in bracket notation</span>
<span class="sd">            dim_V1 (int): dimension of V1</span>
<span class="sd">            V2 (list: in): Line bundle in bracket notation</span>
<span class="sd">            dim_V2 (int): dimension of V2</span>
<span class="sd">            t (int): specifies the normal section used for the map</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (nested list: int): A matrix for the map between the two monomial basis.</span>
<span class="sd">                with entries being the corresponding complex modulis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">V2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">V2</span><span class="p">]</span>
        <span class="n">V1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">V1</span><span class="p">]</span>
        <span class="c1">#smatrix = np.zeros((dim_V1, dim_V2), dtype=np.int16)</span>
        <span class="n">smatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim_V2</span><span class="p">,</span> <span class="n">dim_V1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_makepoly</span><span class="p">(</span><span class="n">V1</span><span class="p">,</span> <span class="n">dim_V1</span><span class="p">)</span> <span class="c1">#only consider positive exponents</span>
        <span class="n">moduli</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">V2</span><span class="p">,</span> <span class="n">V1</span><span class="p">)</span> <span class="c1"># the modulimaps can contain derivatives</span>
        <span class="n">dim_mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_brackets_dim</span><span class="p">(</span><span class="n">moduli</span><span class="p">)</span>
        <span class="n">mod_polys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_makepoly</span><span class="p">(</span><span class="n">moduli</span><span class="p">,</span> <span class="n">dim_mod</span><span class="p">)</span>
        <span class="n">v2poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_makepoly</span><span class="p">(</span><span class="n">V2</span><span class="p">,</span> <span class="n">dim_V2</span><span class="p">)</span>
        <span class="c1"># loop over all monomials</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_V1</span><span class="p">):</span>
            <span class="c1"># loop over all moduli &#39;monomials&#39;</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_mod</span><span class="p">):</span>
                <span class="n">monomial</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">derivative</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># determine the new monomial</span>
                <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mod_polys</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                    <span class="c1"># if y is bigger we simply multiply</span>
                    <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">monomial</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># if smaller we see if taking the partial derivative yields zero</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">:</span>
                            <span class="n">monomial</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># x is of sufficient power we save the factors coming from the derivative</span>
                            <span class="c1"># and lower the exponent appropiately</span>
                            <span class="n">monomial</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">]</span>
                            <span class="c1"># apparently the derivative has to be taken without the prefactors.</span>
                            <span class="c1"># This is justified since, when there is a -1 we should rather imagine</span>
                            <span class="c1"># the map 1/mono -&gt; 1/mono which is not actually a derivative.</span>
                            <span class="c1">#derivative *= int(np.product([z for z in range(x,x+y,-1)]))</span>
                <span class="k">if</span> <span class="n">monomial</span> <span class="o">!=</span> <span class="p">[]:</span>
                    <span class="c1">#brute force approach </span>
                    <span class="c1">#for k in range(len(v2poly)):</span>
                    <span class="c1">#    if np.array_equal(monomial,v2poly[k]):</span>
                    <span class="c1">#        smatrix[k][i] = self.moduli[t][j]*derivative</span>
                    <span class="c1">#        #smatrix[i][k] = self.moduli[t][j]*derivative</span>
                    <span class="c1">#        break</span>
                    <span class="c1">#np approach; factor of ~150 faster</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">monomial</span> <span class="o">==</span> <span class="n">v2poly</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">smatrix</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moduli</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">derivative</span>
                    <span class="c1">#nicer approach which finds the position; not implemented yet.</span>
                    <span class="c1">#pos = self.decoder(monomial, V2, dim_V2)</span>
                    <span class="c1">#smatrix[i][pos] = self.moduli[t][j]*derivative</span>
        <span class="c1">#print(smatrix)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Time:&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">smatrix</span>

    <span class="k">def</span> <span class="nf">_rank_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">V2</span><span class="p">,</span> <span class="n">V1o</span><span class="p">,</span> <span class="n">V2o</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determines the rank of a map between two Leray entries.</span>
<span class="sd">        The function creates a matrix of shape(dim_v1,dim_v2)</span>

<span class="sd">        Args:</span>
<span class="sd">            V1 (nested list: int): list of vector notations from which we map</span>
<span class="sd">            V2 (nested list: int): list of vector notations to which we map</span>
<span class="sd">            V1o (nested list: int): list of origins of all vectors in V1</span>
<span class="sd">            V2o (nested list: int): list of origins of all vectors in V2</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (list: int): dimensions of [kernel, image] of the map; image=rank of the matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#if self.debug:</span>
        <span class="c1">#    directory = self.directory+str([len(V1), len(V2)])</span>
        <span class="c1">#    os.makedirs(directory)</span>
        <span class="c1">#    os.chdir(directory)</span>

        <span class="c1"># Check if V1 or V2 are zero then trivial</span>
        <span class="k">if</span> <span class="n">V1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">V2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dimension</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_brackets_dim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">V1</span><span class="p">]</span>
                <span class="k">return</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">dimension</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># We fill the first list, V1, with bracket notation</span>
        <span class="n">dim_bracket_V1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_brackets_dim</span><span class="p">(</span><span class="n">V1</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V1</span><span class="p">))]</span>
        <span class="n">dim_V1</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dim_bracket_V1</span><span class="p">)</span>

        <span class="c1"># We fill the second list, V2, with bracket notation</span>
        <span class="n">dim_bracket_V2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_brackets_dim</span><span class="p">(</span><span class="n">V2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V2</span><span class="p">))]</span>
        <span class="n">dim_V2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dim_bracket_V2</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We determine the map from&#39;</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">,</span> <span class="n">V2</span><span class="p">,</span> 
                    <span class="s1">&#39;with dimensions&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">dim_bracket_V1</span><span class="p">,</span><span class="n">dim_V1</span><span class="p">],</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">dim_bracket_V2</span><span class="p">,</span><span class="n">dim_V2</span><span class="p">])</span>
            <span class="n">f_n</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V1</span><span class="p">))]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V2</span><span class="p">))]</span>
            <span class="n">f_or</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V1</span><span class="p">))]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V2</span><span class="p">))]</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1">#We create the matrix; int32 since we run into troubles with int16 and big matrices</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim_V2</span><span class="p">,</span> <span class="n">dim_V1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dim_bracket_V1</span><span class="p">)):</span>
            <span class="n">Many</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">_lorigin</span><span class="p">(</span> <span class="n">V1o</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">V2o</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The bundle maps to&#39;</span><span class="p">,</span> <span class="n">Many</span><span class="p">)</span>

            <span class="c1"># y-position in the big matrix</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dim_bracket_V1</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
            <span class="n">ymax</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dim_bracket_V1</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Many</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">Many</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># determine the minus sign for j</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V1o</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">V1o</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">k</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                                <span class="k">break</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
                                <span class="k">break</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_map</span><span class="p">(</span><span class="n">V1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dim_bracket_V1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">Many</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dim_bracket_V2</span><span class="p">[</span><span class="n">Many</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="n">j</span><span class="p">)</span>
                    <span class="c1"># fill the appropiate row in matrix</span>
                    <span class="n">xmin</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dim_bracket_V2</span><span class="p">[:</span><span class="n">Many</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="n">xmax</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dim_bracket_V2</span><span class="p">[:</span><span class="n">Many</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sign</span><span class="o">*</span><span class="n">x</span>
                    <span class="c1">#if self.debug:</span>
                    <span class="c1">#    np.savetxt(str(i)+&#39;to&#39;+str(j)+&#39;.csv&#39;, x, delimiter=&#39;,&#39;, fmt=&#39;%i&#39;)</span>
                    <span class="c1">#    print(&#39;xrange:&#39;, [xmin, xmax, xmax-xmin], &#39;yrange:&#39;,[ymin, ymax, ymax-ymin], &#39;mapshape:&#39;, x.shape)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
                        <span class="n">f_n</span><span class="p">[</span><span class="n">Many</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">V1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">Many</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]])]</span>
                        <span class="n">f_or</span><span class="p">[</span><span class="n">Many</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">sign</span><span class="o">*</span><span class="n">j</span><span class="p">]</span>                    

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creation of the map took: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mid</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;directory created at&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">V1</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">V2</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.csv&#39;</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">)</span>


        <span class="c1"># for large matrices here appears to be the bottleneck;</span>
        <span class="c1"># needs a lot of ram and takes the most time.</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The total map is then:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;in terms of polynomials&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f_n</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;and has rank:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;such that we return for kernel+image:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">([</span><span class="n">dim_V1</span><span class="o">-</span><span class="n">rank</span><span class="p">,</span><span class="n">rank</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Rank calculation took:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">mid</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total time for this map: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">V1o</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;maps via&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f_or</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;to&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">V2o</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">dim_V1</span><span class="o">-</span><span class="n">rank</span><span class="p">,</span><span class="n">rank</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_makepoly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rep</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Takes a bracket notation and creates a monomial basis.</span>
<span class="sd">        Schematically:</span>
<span class="sd">            (1,1) in the ambient space P1*P1 returns:</span>
<span class="sd">            - &gt; [[1,0,1,0],[0,1,1,0],[1,0,0,1],[0,1,0,1]]</span>
<span class="sd">        Each entry denotes the exponent of the respective variable in the ambient space.</span>

<span class="sd">        Args:</span>
<span class="sd">            rep (list: int): A line bundle in bracket notation</span>
<span class="sd">            dim (int): the dimension of that line bundle</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (nested list: int): A basis of monomials</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ambient</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rep</span><span class="p">))]</span>
        <span class="c1"># create all possible ambient space polynomials</span>
        <span class="c1"># run over each ambient space degree</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rep</span><span class="p">)):</span>
            <span class="c1"># create all polynomials of this degree   </span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rep</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ambient</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">apoly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">rep</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ambient</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">apoly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">rep</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="n">ambient</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">ambient</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#if zero there is only the zero combination</span>
                <span class="n">ambient</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="mi">0</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))]</span>
        <span class="c1">#create all combinations</span>
        <span class="n">Base</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ambient</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">rep</span><span class="p">)):</span>
            <span class="n">lenB</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Base</span><span class="p">)</span>
            <span class="n">Base</span> <span class="o">=</span> <span class="n">Base</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">ambient</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ambient</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lenB</span><span class="p">):</span>
                    <span class="c1">#if we want to keep every ambient space in a seperate list</span>
                    <span class="c1"># we need to change here, might run into troubles with</span>
                    <span class="c1"># tuples here.</span>
                    <span class="n">Base</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">lenB</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Base</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">lenB</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">ambient</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="n">polynomial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Base</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">polynomial</span>

<div class="viewcode-block" id="CICY.line_index"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.line_index">[docs]</a>    <span class="k">def</span> <span class="nf">line_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the index of a general line bundle in terms of the charges m_i.</span>
<span class="sd">        Currently only implemented for three folds, where</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{align}</span>
<span class="sd">            \text{ind}(L) = \sum_{q=0}^{n} (-1)^q h^q(X,L) = \frac{1}{6} d_{rst} m^r m^s m^t + \frac{1}{12} c_2^r m_r \; .</span>
<span class="sd">            \end{align}</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        euler: sympyexpr</span>
<span class="sd">            A polynomial in the line bundle charges</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        line_co_euler: Determines the index of a specific line bundle.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.line_index()</span>
<span class="sd">        1.5*m0**2*m1 + 3.5*m0*m1**2 + 3.0*m0 + 0.333333333333333*m1**3 + 3.66666666666667*m1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;m0:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">euler</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drst</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">triple</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drstmatrix</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                        <span class="n">euler</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triple</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">s</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="mi">12</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">secondchern</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">euler</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;not implemented yet&#39;</span>
        <span class="sd">&quot;&quot;&quot;if self.nfold == 4:</span>
<span class="sd">            euler = 0</span>
<span class="sd">            if type(self.quadruple) == str:</span>
<span class="sd">                self.quadruple = self.drstumatrix()</span>
<span class="sd">            for r in range(self.len):</span>
<span class="sd">                for s in range(self.len):</span>
<span class="sd">                    for t in range(self.len):</span>
<span class="sd">                        for u in range(self.len):</span>
<span class="sd">                            # check the prefactos and such</span>
<span class="sd">                            euler += self.quadruple[r][s][t]*(1/6*L[r]*L[s]*L[t]*L[u]+1/12*L[r]*self.thirdchern(s,t,u))</span>
<span class="sd">            return euler&quot;&quot;&quot;</span>        </div>

<div class="viewcode-block" id="CICY.line_co_euler"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.line_co_euler">[docs]</a>    <span class="k">def</span> <span class="nf">line_co_euler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Leray</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the index of a line bundle L.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        L : array[nProj]</span>
<span class="sd">            The line bundle L as a simple list.</span>
<span class="sd">        Leray : bool, optional</span>
<span class="sd">            If True, uses the Leray table to determine the index, by default False.</span>
<span class="sd">            For n=/=3 folds automatically falls back to the Leray table.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        euler: float</span>
<span class="sd">            The index of L.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        line_index: Determines the index in terms of general charges.</span>
<span class="sd">        line_co: Determines the line bundle cohomology of L.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.line_co_euler([-4,3])</span>
<span class="sd">        -46.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># using Chern classes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Leray</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">euler</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drst</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">triple</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drstmatrix</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                            <span class="n">euler</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triple</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">s</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="mi">12</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">secondchern</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The calculation took:&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">euler</span>
            <span class="sd">&quot;&quot;&quot;if self.nfold == 4:</span>
<span class="sd">                euler = 0</span>
<span class="sd">                if type(self.quadruple) == str:</span>
<span class="sd">                    self.quadruple = self.drstumatrix()</span>
<span class="sd">                for r in range(self.len):</span>
<span class="sd">                    for s in range(self.len):</span>
<span class="sd">                        for t in range(self.len):</span>
<span class="sd">                            for u in range(self.len):</span>
<span class="sd">                                # check the prefactos and such</span>
<span class="sd">                                euler += self.quadruple[r][s][t]*(1/6*L[r]*L[s]*L[t]*L[u]+1/12*L[r]*self.thirdchern(s,t,u))</span>
<span class="sd">                if self.doc:</span>
<span class="sd">                    end = time.time()</span>
<span class="sd">                    print(&#39;The calculation took:&#39;, end-start)</span>
<span class="sd">                return euler&quot;&quot;&quot;</span>

        <span class="c1"># Build our Leray tableaux E_1[k][j]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_to_BBW</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">Table1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Leray</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>        
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We determine the index of&#39;</span><span class="p">,</span>
                    <span class="n">L</span><span class="p">,</span> <span class="s1">&#39;over the CICY&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The first Leray instance takes the form:&#39;</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">Texttable</span><span class="p">()</span>
            <span class="n">t</span><span class="o">.</span><span class="n">add_row</span><span class="p">([</span><span class="s1">&#39;j</span><span class="se">\\</span><span class="s1">K&#39;</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
            <span class="c1">#print(Table1)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimA</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">t</span><span class="o">.</span><span class="n">add_row</span><span class="p">([</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
            <span class="nb">print</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
        
        <span class="n">euler</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Table1</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">euler</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_brackets_dim</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> 

        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;euler: &#39;</span><span class="p">,</span> <span class="n">euler</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The calculation took:&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">euler</span></div>

<div class="viewcode-block" id="CICY.l_slope"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.l_slope">[docs]</a>    <span class="k">def</span> <span class="nf">l_slope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">dual</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the zero slope condition of a line bundle on a favourable CICY</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{align}</span>
<span class="sd">            \mu (L) = c_1^i (L) d_{ijk} t^j t^k = 0 \; .</span>
<span class="sd">            \end{align}</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        line : array[nProj]</span>
<span class="sd">            The line bundle L.</span>
<span class="sd">        dual : bool, optional</span>
<span class="sd">            If true, uses dual coordinates k_i = d_{ijk} t^j t^k, by default False.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        slope: bool</span>
<span class="sd">            True, if it can be satisfied somewhere in the Kähler cone.</span>
<span class="sd">        solution: sympyexpr</span>
<span class="sd">            The slope condition.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        line_slope: Returns the slope in terms of general charges.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.l_slope([-4,3])</span>
<span class="sd">        (True, [9.0*t0**2 + 18.0*t0*t1 - 22.0*t1**2])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># define the Kähler moduli</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t0:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)))</span>
        <span class="c1"># find constraint</span>
        <span class="n">constraint</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fav</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">constraint</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dual</span><span class="p">:</span>
            <span class="c1"># in terms of kähler moduli</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)):</span>
                        <span class="n">factor</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">drst</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">constraint</span> <span class="o">+=</span> <span class="n">factor</span><span class="o">*</span><span class="n">ts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">ts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

            <span class="n">coeff</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Poly</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span><span class="o">.</span><span class="n">coeffs</span><span class="p">()</span>
            <span class="c1">#check if we have mixed coefficients</span>
            <span class="nb">all</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coeff</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">coeff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">all</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">all</span> <span class="o">-=</span> <span class="mi">1</span>
            
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">all</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeff</span><span class="p">):</span>
                <span class="n">slope</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slope</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The slope stability constraint reads:&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">([</span><span class="n">constraint</span><span class="p">])</span><span class="c1">#+kaehlerc</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="n">constraint</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">slope</span><span class="p">,</span> <span class="n">solution</span>
        
        <span class="c1"># we use the dual coordinates</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)):</span>
            <span class="n">constraint</span> <span class="o">+=</span> <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1">#kaehlerc = [x &gt; 0 for x in ts]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The slope stability constraint reads:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">([</span><span class="n">constraint</span><span class="p">])</span><span class="c1">#+kaehlerc</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="n">constraint</span><span class="p">]</span><span class="c1">#+kaehlerc</span>
        <span class="k">return</span> <span class="n">slope</span><span class="p">,</span> <span class="n">solution</span></div>

<div class="viewcode-block" id="CICY.line_slope"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.line_slope">[docs]</a>    <span class="k">def</span> <span class="nf">line_slope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the slope of a general line bundle over a favourable CY.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        constraint: sympyexpr</span>
<span class="sd">            Sympyexpression of the slope.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        l_slope: The zero slope condition of a line bundle L.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.line_slope()</span>
<span class="sd">        6.0*m0*t0*t1 + 7.0*m0*t1**2 + 3.0*m1*t0**2 + 14.0*m1*t0*t1 + 2.0*m1*t1**2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;m0:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">))</span>
        <span class="n">constraint</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t0:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fav</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">):</span>
                            <span class="n">factor</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">drst</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">constraint</span> <span class="o">+=</span> <span class="n">factor</span><span class="o">*</span><span class="n">ts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">ts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">constraint</span>
        <span class="k">return</span> <span class="s1">&#39;not implemented&#39;</span></div>


<div class="viewcode-block" id="CICY.line_co"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.CICY.line_co">[docs]</a>    <span class="k">def</span> <span class="nf">line_co</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">short</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The main function of this CICY toolkit. It determines the cohomology of a line bundle over the CY.</span>
<span class="sd">        Based on the Leray spectral sequence and Bott-Borel-Weil theorem. Makes use of the index and vanishing theorem</span>
<span class="sd">        to shorten computation time.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        L : array[nProj]</span>
<span class="sd">            The line bundle L.</span>
<span class="sd">        space : bool, optional</span>
<span class="sd">            If True returns the cohomology in term of maps, rather than the dimension, by default False.</span>
<span class="sd">        short : bool, optional</span>
<span class="sd">            If False, calculates the rank of all maps and does not make use of simplifications, by default True.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hodge: array[nfold+1]</span>
<span class="sd">            hodge numbers of the line bundle L.</span>
<span class="sd">        hspace: nested list, optional</span>
<span class="sd">            If space, then also a nested list of maps is returned.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        line_co_euler: Returns the index of a line bundle</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; M = CICY(&#39;7833&#39;, [[2,2,1],[3,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; M.line_co([-4,3])</span>
<span class="sd">        [0,46,0,0]</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] CY - The Bestiary, T. Hubsch</span>
<span class="sd">            http://inspirehep.net/record/338506?ln=en</span>

<span class="sd">        .. [2] Heterotic and M-theory Compactifications for String Phenomenology, L. Anderson</span>
<span class="sd">            https://arxiv.org/abs/0808.3621</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Build our Leray tableaux E_1[k][j]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_to_BBW</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">Table1</span><span class="p">,</span> <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Leray</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="c1">#Next E_2[k][j]</span>
        <span class="n">E2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimA</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        
        <span class="c1">#space</span>
        <span class="n">spacetable</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimA</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">hspace</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We determine the line bundle cohomology of&#39;</span><span class="p">,</span>
                    <span class="n">L</span><span class="p">,</span> <span class="s1">&#39;over CICY&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The first Leray instance takes the form:&#39;</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">Texttable</span><span class="p">()</span>
            <span class="n">t</span><span class="o">.</span><span class="n">add_row</span><span class="p">([</span><span class="s1">&#39;j</span><span class="se">\\</span><span class="s1">K&#39;</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
            <span class="c1">#print(Table1)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimA</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">t</span><span class="o">.</span><span class="n">add_row</span><span class="p">([</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
            <span class="n">sdir</span> <span class="o">=</span> <span class="s1">&#39;l&#39;</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
                <span class="n">sdir</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="o">+</span><span class="n">sdir</span>

        <span class="c1"># variables for the image</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;f0:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">euler</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimA</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">dimension</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_brackets_dim</span><span class="p">(</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">a</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]))])</span> 
                    <span class="n">euler</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">dimension</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dimension</span>
                        <span class="n">spacetable</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">images</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">spacetable</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="kc">False</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">valj</span> <span class="o">=</span> <span class="n">j</span>
                            <span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dimension</span><span class="o">-</span><span class="n">images</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                            <span class="n">spacetable</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="kc">True</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">images</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                                    <span class="n">spacetable</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="kc">False</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">Table1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="c1"># rare case for at least one zero in the charges</span>
                                    <span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_brackets_dim</span><span class="p">(</span><span class="n">Table1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">a</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Table1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]))])</span>
                                    <span class="n">spacetable</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Table1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="kc">False</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dimension</span>
                            <span class="n">spacetable</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">images</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                                    <span class="n">spacetable</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="kc">False</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">Table1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="c1"># in principal we would have to determine the map here, but this case is only triggered for </span>
                                    <span class="c1"># when some charges are zero and then the map will fully inject</span>
                                    <span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_brackets_dim</span><span class="p">(</span><span class="n">Table1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">a</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Table1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]))])</span>
                                    <span class="n">spacetable</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Table1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="kc">False</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We find for the second Leray instance:&#39;</span><span class="p">,</span> <span class="n">E2</span><span class="p">)</span>

        <span class="n">hodge</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfold</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E2</span><span class="p">)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">E2</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">hodge</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">+=</span> <span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">k</span><span class="o">+</span><span class="n">q</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">spacetable</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">k</span><span class="o">+</span><span class="n">q</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">hspace</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">spacetable</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">k</span><span class="o">+</span><span class="n">q</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">hodge</span><span class="p">[</span><span class="n">q</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">done</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Such that we find for the hodge numbers:&#39;</span><span class="p">,</span> <span class="n">hodge</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The calculation took:&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">space</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">hodge</span><span class="p">,</span> <span class="n">hspace</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">hodge</span>
        
        <span class="c1"># now there is a theorem stating if L is slope stable,</span>
        <span class="c1"># then H^0 = H^3 = 0 by Serre.</span>
        <span class="c1"># only holds for favourable CY</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fav</span> <span class="ow">and</span> <span class="n">short</span><span class="p">:</span>
            <span class="n">stable</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_slope</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">dual</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stable</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">short</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">stable</span><span class="p">:</span>
                    <span class="n">hspace</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">hspace</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">solution</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="n">hodge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hodge</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">hodge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">hodge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">euler</span><span class="p">],</span> <span class="n">images</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">solution</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">hodge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">hodge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">hodge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">hodge</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">euler</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">stable</span><span class="p">:</span>
                    <span class="n">hspace</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">hspace</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">solution</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="n">hodge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hodge</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">hodge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">hodge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">euler</span><span class="o">-</span><span class="n">hodge</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span> <span class="n">images</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">solution</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">hodge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">hodge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">hodge</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-</span><span class="n">hodge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">hodge</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">euler</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfold</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">stable</span><span class="p">:</span>
                    <span class="n">hspace</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">hspace</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">solution</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="n">hodge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hodge</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">hodge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">euler</span><span class="p">],</span> <span class="n">images</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">solution</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">hodge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">hodge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">hodge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">euler</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="ow">and</span> <span class="n">short</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;we find for the hodge numbers&#39;</span><span class="p">,</span> <span class="n">hodge</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;with the following constraints&#39;</span><span class="p">,</span> <span class="n">solution</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;coming from Euler characteristic and slope stability.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">short</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hodge</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">hodge</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span>
                                <span class="n">hodge</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">hodge</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hodge</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">hodge</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span>
                            <span class="n">hodge</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">hodge</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="ow">and</span> <span class="n">short</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;After substituting we find:&#39;</span><span class="p">,</span> <span class="n">hodge</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Next we calculate the relevant maps.&#39;</span><span class="p">)</span>


        <span class="c1"># get all the maps we have to calculate</span>
        <span class="n">maps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">hodge</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">maps</span> <span class="o">+=</span> <span class="n">entry</span><span class="o">.</span><span class="n">free_symbols</span>        
        <span class="n">maps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">maps</span><span class="p">))</span>

        <span class="c1"># calculate all the maps</span>
        <span class="c1"># there could be a problem for line bundles with 0 charges when short=False</span>
        <span class="n">maps_c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">maps</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">maps</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">maps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">images</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                    <span class="n">maps_c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank_map</span><span class="p">(</span><span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">valj</span><span class="p">],</span> <span class="n">Table1</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">valj</span><span class="p">],</span> <span class="n">origin</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">valj</span><span class="p">],</span> <span class="n">origin</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">valj</span><span class="p">])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;the image&#39;</span><span class="p">,</span> <span class="n">maps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;is&#39;</span><span class="p">,</span> <span class="n">maps_c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># substitute all values</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">maps</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hodge</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">hodge</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span>
                    <span class="n">hodge</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">hodge</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">maps_c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hodge:&#39;</span><span class="p">,</span> <span class="n">hodge</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The calculation took:&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">space</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hodge</span><span class="p">,</span> <span class="n">hspace</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hodge</span></div></div>


<span class="c1">#@staticmethod</span>
<div class="viewcode-block" id="apoly"><a class="viewcode-back" href="../../pyCICY.html#pyCICY.pyCICY.apoly">[docs]</a><span class="k">def</span> <span class="nf">apoly</span><span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="n">deg</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">deg</span><span class="p">,)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">apoly</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="n">deg</span> <span class="o">-</span> <span class="n">i</span><span class="p">):</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">i</span><span class="p">,)</span> <span class="o">+</span> <span class="n">j</span>        </div>
    
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
    
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">pyCICY</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">pyCICY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../howto.html">How to use pyCICY</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Robin Schneider.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>